블록 암호는 고정된 사이즈의 블록을 암호화시킨다. 예를 들어 DES는 56비트의 키와 8비트의 오류검출비트로 이루어진 64비트의 블록을 사용한다. 하지만 적은 비트와 고정된 사이즈를 가진 DES가 파훼되면서 다양한 사이즈의 블록을 암/복호화 할 수 잇는 방식에 대한 필요성이 대두되었다.
그간 하나의 키를 반복해서 사용하는 것에 대한 문제점이 지적되었는데, 블록 암호 운용 방식은 하나의 키를 반복 사용하되 안정성을 함께 제공하는데 그 목적이 있다. 모든 블록 암호는 데이터를 암호화 하기 전에 블록 단위로 나누어야 하는데, 이 블록들을 어떻게 암호화 할 것인가에 대한 방식을 논하는 것을 블록 암호 운용 방식이라고 부른다.
NIST SP 800-38A에서는 5가지 블록 암호 운용 방식에 대하여 5가지 모드를 정의하고 있다.

(1) ECB(Electronic Code Book)
ECB는 가장 간단한 구조를 가지며 평문을 여러 블록으로 나누어 암호화하는 방식이다.  각각의 블록은 동일한 하나의 키를 사용하지만 각각 독립적으로 동작한다. 독립적으로 동작한다는 것은 한 블록에서 에러가 발생해도 다른 블록에 영향을 끼치지 않는다는 의미이다. ECB는 주로 단일 블록을 암호화하여 안전하게 전송하기 위한 목적으로 사용한다. 같은 키로 여러 개의 블록을 암호화하다보면 취약해지기 때문에 단일 블록 암호화를 권장한다.
당연히 하나의 키를 사용하는 만큼 보안적으로 취약하다. 같은 평문이 암호화 되면 같은 암호문이 나오기 때문이다.
하나의 블록이 풀렸다는 것은 곧 키가 노출되었다는 것을 의미하므로,다른 블록도 연쇄적으로 풀리게 된다.
이는 Brute force 공격에 매우 취약한 특징이다.

(2) CBC (Cipher Block Chaining)
동일 input -> 동일 output의 문제를 해결한 방식이다. 각 평문 블록은 앞에서 암호화된 블록과 XOR 연산한 결과로 암호화 된 블록을 생성하며, 첫 블록은 IV(Initial Vector)가 사용된다. 즉, IV는 아래 그림에서 C0의 역할을 한다. IV가 같을 경우 출력 결과가 같아지기 때문에 매번 다른 IV를 사용해야 한다. IV는 고정된 값으로 부여하거나, ECB 모드로 암호화한 값을 전달받는다. CBC 방식은 현재도 널리 쓰이고있다.
암호화 시에는 각 루틴이 이전 결과에 의존하기 때문에 병렬 작업이 불가능한 직렬 작업이다. 복호화 시에는 각 블록을 복호화 한 다음 이전 암호화 블록과 XOR하여 복구할 수 있기 때문에 복호화 과정에서는 병렬화가 가능하다. 다시 말해, 특정 블록 복호화는 이전 블록만 있으면 가능하기 때문에, 이미 블록이 모두 구해져 있는 상태인 복호화 과정에서는 병렬 작업이 가능한 것이다. CBC는 주로 인증코드에 사용된다.

(3) CFB-s (Cipher FeedBack)
CBC 방식의 변형이며 s는 s bit 단위로 암호화 하겠다는 의미이다. 그림을 자세히 보면 평문 P가 암호화 과정(Encrypt)에 들어가지 않는다. IV를 암호화하고 그 결과를 평문의 사이즈(s bit)만큼 잘라서 평문과 XOR한다. 그럼 s bit 사이즈의 암호문 C1이 나오고, 이 C1은 CBC에서처럼 다음 블록의 암호화에 연쇄적으로 쓰인다. 결과적으로 평문과 암호문의 사이즈는 같은 블록사이즈이고, CBC와 마찬가지로 암호화는 순차적, 복호화는 병렬적 처리가 가능하다. 

(4) OFB (Outpurt FeedBack)
암/복호화 과정에서 빗금친 부분의 Key와 Nonce의 Encrypt 과정은 평문과는 독립적으로 동작하기 때문에 순차 처리가 필요 없고 병렬 작업이 가능하다. Encrypt의 결과 길이가 P1과 맞지 않으면 CFB처럼 s bit으로 블록 사이즈를 맞추는 작업이 가능하며, 암호화 자체는 bit 단위로 되기 때문에 스트림 암호화이다.
Encrypt가 미리 계산 가능하며, 평문의 부분 부분만 암호화가 가능하다는 장점이 있지만  Key를 몰라도 평문과 암호문만 있으면 Encrypt의 결과물 자체는 알 수 있다는 단점이 있다. 이 단점은 보안상의 취약점으로 작용할 수 있으며, 그래서 한 번 사용한 Nonce는 절대 다시 사용해서는 안된다. OFB는 noisy channel에서 데이터를 전송할 때 스트림 암호화에 사용한다.

(5) CTR (Counter)
Counter1~N은 블록을 암호화 할 때마다 1씩 증가하며, 각 루틴이 완전히 독립되어있다. 점선으로 표시된 영역 내에서조차 독립성이 있으므로 전체 암호화 과정이 Totally Parallel 하다. 완전 병렬작업이 가능하기에 속도가 빨라서 high-speed network에서 사용된다. 빠른만큼 구조는 단순하고, 보안상의 취약점이 될 수 있기에 counter 와 key값은 다시 재사용하지 않는다.

(6) Tweakable Block Cipher
암호화를 진행하기 전에 Tweak값을 이용하여 한 번 꼬아준다고 해서 Tweakable Cipher라고 한다. Tweak이 제공하고자 하는 것은 '다양성'이다. 암호에서 언제나 고민하는 것이 바로 동일한 input이 동일한 output을 낳는 문제인데, Tweak값을 이용하여 암호화 과정 전에 한 번 더 평문을 변형시켜주는 과정을 거쳐 이 문제를 해결한다.
복호화 과정도 어렵지 않다. Tj와 K값만 알면 가능한데, Tj나 Pj가 오픈된다고 해도 K를 모르면 복호화가 불가능하다. 따라서 Tj Pj는 공개된다. 두 개의 블록 내용이 같고 K값이 같더라도 Tweak이 다르면 결과가 달라지므로 무작위성을 띄는 장점이 있다. 이 장점을 활용한 것으로 XTS-AES가 있다.

(7) XTS-AES
블록 단위 저장장치에서 사용할 수 있는 새로운 암호방식이다. Tweakable block cipher의 컨셉을 이어받았으며, 각각의 블록에 대하여 AES를 두 번 적용하며 Chaining은 없다.
XTS-AES의 특징은 맨 마지막에 자투리 처리방식이다. 맨 마지막에는 Cm이 블록 사이즈와 맞지 않는데도 암-복호화 처리가 가능하다는 것이다.
