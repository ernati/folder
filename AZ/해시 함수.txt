해시함수란 입력으로 들어오는 메세지 M의 길이가 정해져 있지 않으나 출력의 길이는 고정된 사이즈를 반환하는 함수이다. 입력으로 들어오는 메세지의 값이 조금이라도 바뀌면 결과로 출력되는 해시값은 완전히 다른 값으로 나오게 된다. 따라서 메세지의 변조를 확인하는 데 해시값이 쓰인다.
해시 함수의 특징은 단방향이다. 해시 함수를 이용해서 변환한 값을 나중에 필요에 의해 다시 되돌려 쓰기 위한 것이 아니라 메세지를 고정된 사이즈의 출력으로 바꾸는데서 그 역할을 다 하기 때문이다.  즉, 해시와 암호화의 차이는 M값을 되돌리느냐 되돌리지 않느냐라는 점에서 큰 차이가 있다.
또 한 가지 특징은 충돌 방지이다. 서로 다른 M값을 해시함수 H()에 넣었을 때 같은 해시값을 출력하지 않는다는 것이다. 이 특징이 깨지면 그 해시함수는 신뢰성을 잃은 것이기 때문에 사용할 수 없다. Input은 무한한데, Output의 사이즈는 고정되어 있기 때문에 이 충돌은 언젠가 발생할 수 밖에 없지만 이 충돌의 발생가능성을 최대한 억제시키는 것이 중요하다.
해시함수는 데이터의 무결성을 보장하기 위해 사용하지만, 중간자가 끝에 붙는 해시값 부분을 제외하고 데이터 부분만 조작하면 해시는 그 기능을 잃는다. 때문에 암호화가 필요해진다.

​01) 해시함수와 메세지 인증(Hash Functions & Message Authentication)
(a) 원래 메세지 M에다가 메세지를 해시한 H(M)을 붙인다. 그리고 이 덩어리를 통째로 암호화한다.
받는 사람은 이 덩어리를 복호화해서 얻은 M을 해시하고 H(M)과 일치하는지 비교한다.
(b) 굳이 숨겨야 할 데이터가 아니라면, H(M)만 암호화 해서 M과 붙인다. 그렇게 하더라도 여전히 공격자는 K값을 모르는 상태에서 조작할 수 없고, K값을 알고 있는 인증된 사용자는 복호화해서 얻어낸 M을 해시하여 H(M)과 비교할 수 있다.
(c) 메세지 M의 뒤에 사전에 공유된 비밀값 S를 붙인 후 이 덩어리를 통째로 해시한다. 그리고 M에 붙인다. K값을 이용한 암호화나 마찬가지 역할을 하게 된다. 수신자는 받은 결과에서 M에 S를 붙여 해시하고 전송받은 H(M||S)와 비교한다.
(d) M값의 뒤에 사전에 공유된 비밀값 S(Shared secrte value)를 붙인다. M||S를 해시한 결과와 M을 다시 이어붙이고 암호화한다. 역시 공격자는 S를 모르기 때문에 변조할 수 없게 된다. 수신자는 이를 복호화하여 H(M||S)의 결과와, 복원한 M에 사전에 공유된 S를 붙여 직접 해시한 결과를 비교한다.

02) 전자 서명(Digital Signature)
디지털 서명이란 메세지 M에 대한 해시값 H(M)을 개인키로 암호화 한 것이다. 물론 메세지 전부를 암호화 하는 방법도 있지만 메세지 전체를 암호화 하는 것은 비용(시간)이 많이 들기 때문에 효율적이지 못하다. 그래서 사이즈가 고정되어있는 H(M)을 이용하는 것이다.  전자 서명은 반드시 비대칭키 방식으로만 가능하다. 전자서명과 MAC은 완전히 다른 서비스이다.

03) 그 외 용도

password file을 저장할 때도 사용한다. 패스워드를 해시로 변형한 값을 파일에 저장하는 방식인데, 특히 리눅스에서 쉽게 확인할 수 있는데, 일반적으로 패스워드 생성에 사용되는 해시 알고리즘은 공개되어 있는 경우가 많으므로 공격자들은 예상되는 패스워드의 해시값을 미리 계산해 놓는다. 이러한 방식의 공격을 Dictionary Attack이라 한다. 이 사전공격을 방지하기 위해 솔트(salt)값이라 불리는 숫자를 섞어 해시한다.
또한 virus detection에도 사용할 수 있다. 파일의 해시값을 확인함으로써 변조된 파일인지 확인할 수 있기 때문이다.
마지막으로 Pseudorandom function(PRF) 또는 Pseudorandom number generator(PRNG)로 사용할 수 있다.

04) 해시함수에 대한 공격
- A Preimage or second preimage attack : H(x)에서 x를 찾아내거나, H(x) = H(y)를 만족하는 경우를 찾아낸다.
-Collision resistance : H(x) = H(y)를 만족하는 (x,y) 쌍을 찾아낸다.
- Brithday Attack : 원본 계약서 X가 존재하고, a가 서명해서 계약하는 정상적인 상황이 있다. 그리고 누군가는 가짜계약서 Y에 a가 서명한 것 처럼 만들고 싶어한다. 사실상 위에 언급된 H(x) = H(y)인 케이스를 찾아내지 않는 한 불가능하다. 그런데 Birthday Attack은 이 확률을 우연이라고 할 수 없을 정도(50%이상)까지 높여 공격하는 방식이다.
내용은 같지만 외형만 다른 원본 계약서의 변형을 만들어낸다. 여기에 대응하여 가짜 계약서의 변형도 여러개 만들어낸다. 각각 이들의 해시값을 구하면 이들 중에서 해시값이 같은 값이 나올 확률이 50%가 넘는다는 것이다. 위의 그림에서 n=m/2이고, m은 해시 알고리즘의 bit 수이다. 때문에 m이 256bit 이상으로 충분히 커지면 이 공격은 사실상 어려워진다. m이 커진다는 의미는 고정된 크기가 커진다는 뜻이고 collision 발생 확률이 낮아지기 때문에 공격 성공 확률도 낮아지기 때문이다.

05) 안전한 해시 알고리즘
- SHA-1: 160bit을 사용하여 1995년에 발표된 알고리즘이다. 하지만 160bit로는 더이상 보안성을 확보할 수 없었기에 SHA-2가 나오게 되었다. SHA-2는 세 가지 버전이 있다(SHA-256,384,512). 그러나 SHA-2는 SHA-1의 비트 수를 늘린 것에 불과하기에, SHA-1이 이미 깨진 상태에서 SHA-2는 시간이 지나면 결국 정복된다. 그래서 현재 상용화 된 것은 SHA-2 이지만 SHA-3가 이미 개발되어 준비중이다.
- SHA-3 : 2007년에 SHA-3 을 위한 competition을 열었고, 우승한 design을 2012년에 적용하여 발표했다. SHA-3은 Sponge Construction이라는 특징을 가진다. 