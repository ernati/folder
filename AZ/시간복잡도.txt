효율적인 알고리즘이란, 입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘을 구성했다는 것입니다. 시간 복잡도는 주로 빅-오 표기법을 사용해 나타냅니다.
시간복잡도는 Big-O, Big-Ω, Bid-θ 세가지 방법을 사용해 표기합니다. 세 가지 표기법은 시간 복잡도를 각각 최악, 최선, 중간의 경우에 대해 나타내는 방법입니다. 빅오 표기법은 최악의 경우를 고려하므로, 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려할 수 있습니다. 한 마디로, "이 정도 시간까지 걸릴 수 있다." 로 표현할 수 있습니다. 최선의 경우 또는 평균값을 기대하는 시간 복잡도로 알고리즘을 구현한다면, 최악의 경우 어디에서 문제가 발생했는지 알아내기 위해 로직의 많은 부분을 파악해야 하므로 문제를 파악하는 데 많은 시간이 필요합니다. 그래서, 최악의 경우도 고려하여 대비 하는 것이 바람직하기 때문에 다른 표기법보다 빅오 표기법을 많이 사용합니다.
O(1)은 constant complexity라고 하여, 입력값이 증가하더라도 시간이 늘어나지 않습니다. 상수의 시간 복잡도라는 의미이기 때문에, 입력값의 크기와 관계없이, 즉시 출력값을 얻어낼 수 있습니다.
O(n)은 Linear complexity라 하며, 입력값이 증가함에 따라 시간 또한 선형적으로 같은 비율로 증가하는 것을 의미합니다. 입력값이 1일 때 1초의 시간이 걸리고, 입력값을 100배로 증가시킬 때 1초의 100배인 100초가 걸리는 알고리즘의 경우, O(n)의 시간복잡도를 가집니다.
O(log n)은 Logarithmic complexity라고 부르며 빅오 표기법 중 O(1) 다음으로 빠른 시간 복잡도를 가집니다. BST(Binary Search Tree) 의 경우, 원하는 값을 탐색할 때, 노드를 이동할 때마다 경우의 수가 절반으로 줄어듭니다. 이 경우 O(log n)의 시간 복잡도를 가진 알고리즘입니다.
O(n^2)은 quadratic complexity라고 부르며, 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미합니다. 예를 들어 입력값이 1일 경우 1초가 걸리던 알고리즘에 5라는 값을 주었더니 25초가 걸리게 된다면, 이 알고리즘의 시간 복잡도는 O(n^2)라고 표현합니다.
O(2^n 은 Exponential complexity라고 부르며 빅오 표기법중 가장 느린 시간 복잡도를 가집니다.