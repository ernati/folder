1)원리
RSA는 정수론에 기반하여 매우 큰 수의 인수분해 계산을 어렵게 하는 방법으로 암호화 하는 기법이다. 물리적으로 계산이 불가능 한 것은아니지만 현실적으로 매우 어렵다는 의미이다. 하드웨어 성능이 비약적으로 발전하고 있지만 RSA는 그 때 마다 사용하는 비트 수를 점진적으로 늘려가면서 계산을 복잡하게 만드는 방법으로 지금까지 널리 쓰이고 있으며, 현재는 최소한 2048 비트를 사용해야 한다. 만약 하드웨어 성능이 어느날 갑자기 극단적으로 발전한다면 RSA는 깨질 것이다.
송신자 측에 바이너리(숫자형) 메세지 M이 있다. 공개키 PU = (e,n) 을, 개인키 PR = (d,n)가 준비되고 암호문 C= M**e mod n 이다. 이 때, 반드시! 0<=M<=n 이어야 하는데, n보다 M이 커지면 M**e를 했을 때 정보가 상실되기 때문이다. 당연히 C를 복호화 하는 것은 C**d = (M**e)**d 가 되겠다. e와 d는 mod n에서 역수 관계인 것이다.
e와 d가 선택되는 과정은 다음과 같다. 매우 큰 서로다른 두 소수 p와 q를 무작위로 선택한다. 이 두 개의 소수 p,q는 절대로 공개되어서는 안된다. n = pq 가 되고, ϕ(n) = (p-1)(q-1)이다. n이 매우 크면 ϕ(n)을 구하는 것도, p와 q를 구하는 것도 어려워지는데 바로 이것이 RSA 보안성의 핵심이 되는 부분이다.
이제 1< e < ϕ(n) 이면서 gcd(e,ϕ(n)) = 1인 e를 하나 선택한다. gcd(e,ϕ(n))=1 이 조건인 이유는 d의 존재를 보장하기 위해서이다. mod ϕ(n)에서 e의 역수는 d가 되고, 이제 PU=(e,n), PR(d,n)을 만들어 낼 수 있다.

RSA의 암호화 과정은 e의 크기에 따라 걸리는 시간이 변한다. e가 작을 수록 암호화 속도는 빨라질 것이다. 적당한 크기의 e를 고정한다고 해도 ϕ(n)에서 e의 역수가 되는 d를 찾아야 하므로 공격자는 d를 알아낼 수 없기 때문에 괜찮은 아이디어이다. 그러나 e가 너무 작아지면 공격에 취약해질 수 있으며, 권장하는 바로는 e와 d의 크기가 어느정도의 균형을 이루는 것이 좋다고 한다.

3) RSA의 보안성
RSA를 공격하기 위한 접근법으로 가능한 몇 가지가 있다.
- brute force
- mathematical attack : n=pq에 대한 인수분해 연산을 직접 해서 ϕ(n)을 구하는 방법
- timing attack : 계산에 걸리는 시간으로 자릿수를 유추하여 key 값의 범위를 줄여나가는 방법
- chosen ciphertext attack : RSA의 암호문이 가지는 속성 자체를 이용하는 공격

*mathematical attack
수학적 접근법은 무엇을 구하고자 하는가에 따라 3가지 형태로 나누어질 수 있다.
- 인수분해 연산으로 n=pq를 구해서 ϕ(n)을 얻어내고 d를 구한다
- 나름대로 ϕ(n)값을 결정하고 그에 대응하는 d를 구해본다
- 바로 d를 찾아낸다

어떤 방법이든 현재의 하드웨어 성능이나 알고리즘으로는 사실상 불가능하다고 봐야 하나, 어디까지나 안전한 p와 q를 선택했을 때의 이야기이다. 그렇다면 p와 q를 선택할 때 어떤 사항을 고려해야 하는가?
우선 p와 q의 길이는 서로 달라야 하며, 그 차이가 너무 커서는 안된다. similar size라고 할 수 있을 정도의 범위, 1024bit RSA 기준으로 p와 q는 10^75 ~ 10^100 사이에 있는 것이 좋다. 다음으로 p-1과 q-1이 가능한 큰 소수인 약수를 가지고 있는 수일수록 좋다. 마지막으로 gcd(p-1,q-1)이 작을수록 좋다.

*timing attack
대응 방안은 간단하다. 첫째, expoenetiation 연산의 시간을 고정한다. 먼저 끝나도 고정된 시간까지 헛바퀴를 돌게 하는 것이다. 또는, random한 delay를 추가하는 방법도 있다. 마지막으로, 암호화하고자 하는 값 자체를 블라인드 처리하여 계산하는 방법이 있다. 예를 들어, M1과 M2를 곱하고 싶은데 곱셈 연산이 불가능하여 계산 외주를 맡기게 되는 상황을 가정하자. 이 때 M1과 M2는 당연히 노출되면 안되는 원본 정보이므로 e승하여 C1 = M1^e와 C2 = M2^e 를 넘겨준다. 외주 업체는 C1*C2를 연산하여 돌려줄 것이고, C1*C2 = (M1*M2)^e 이므로 개인키 d를 가지고 있는 나는 안전하게 계산 결과를 얻을 수 있다. 이 방법을 timing attack을 방지하기 위해서도 사용할 수 있겠다.

*Chosen Ciphertext Attack(CCA)

RSA는 CCA 공격에 취약하다. 위에 소개된 방법들과 달리 하나의 해킹기법에 가까운데, RSA의 특성을 역이용한 공격기법이다. A와 B가 공개키 기법을 이용하여 통신하는 과정에서, A는 B의 공개키로 암호화하여 B에게 데이터를 보낸다. 이 때 A는 이 공개키가 B의 공개키가 맞는지 확인하기 위해 랜덤한 값 Nonce를 보내 B의 개인키로 암호화하여 돌려줄 것을 요구한다. 그러면 A는 돌아온 값을 B의 공개키로 풀어서 자신이 보낸 Nonce가 맞는지 확인함으로써 서로를 신뢰할 수 있는 것이다.
이 때 만약, A가 악의적인 목적으로 접근한 공격자이고 C=M^e를 마치 Nonce인 것 처럼 보낸다면? B는 자신의 개인키 d로 풀어서 M을 A에게 돌려줄 것이고, 공격자 A는 원본 정보인 M을 탈취할 수 있게 된다. 여기에 더하여 B가 이를 인지하지 못하도록 C를 약간 변형한 X = C*2^e = (M*2)^e를 보낸다. 이것이 Chosen Cipher Attack이다. E(M1) * E(M2) = E(M1*M2) 를 동형특성(Homomorphic property)라고 한다.